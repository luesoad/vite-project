{
  "version": 3,
  "sources": ["../../svelte-router-spa/src/store.js", "../../svelte-router-spa/src/router/url_parser.js", "../../svelte-router-spa/src/lib/utils.js", "../../svelte-router-spa/src/router/current.js", "../../svelte-router-spa/src/router/guard.js", "../../svelte-router-spa/src/router/redirect.js", "../../svelte-router-spa/src/router/route.js", "../../svelte-router-spa/src/router/path.js", "../../svelte-router-spa/src/router/finder.js", "../../svelte-router-spa/src/spa_router.js", "../../svelte-router-spa/src/components/route.svelte", "../../svelte-router-spa/src/components/router.svelte", "../../svelte-router-spa/src/components/navigate.svelte"],
  "sourcesContent": ["import { writable } from 'svelte/store';\n\nconst { set, subscribe } = writable({});\n\nconst remove = () => {\n  set({});\n};\n\nconst activeRoute = {\n  subscribe,\n  set,\n  remove,\n};\n\nexport { activeRoute };\n", "const UrlParser = (urlString, namedUrl = '') => {\n  const urlBase = new URL(urlString);\n\n  /**\n   * Wrapper for URL.hash\n   *\n   **/\n  function hash() {\n    return urlBase.hash;\n  }\n\n  /**\n   * Wrapper for URL.host\n   *\n   **/\n  function host() {\n    return urlBase.host;\n  }\n\n  /**\n   * Wrapper for URL.hostname\n   *\n   **/\n  function hostname() {\n    return urlBase.hostname;\n  }\n\n  /**\n   * Returns an object with all the named params and their values\n   *\n   **/\n  function namedParams() {\n    const allPathName = pathNames();\n    const allNamedParamsKeys = namedParamsWithIndex();\n\n    return allNamedParamsKeys.reduce((values, paramKey) => {\n      values[paramKey.value] = allPathName[paramKey.index];\n      return values;\n    }, {});\n  }\n\n  /**\n   * Returns an array with all the named param keys\n   *\n   **/\n  function namedParamsKeys() {\n    const allNamedParamsKeys = namedParamsWithIndex(namedUrl);\n\n    return allNamedParamsKeys.reduce((values, paramKey) => {\n      values.push(paramKey.value);\n      return values;\n    }, []);\n  }\n\n  /**\n   * Returns an array with all the named param values\n   *\n   **/\n  function namedParamsValues() {\n    const allPathName = pathNames();\n    const allNamedParamsKeys = namedParamsWithIndex();\n\n    return allNamedParamsKeys.reduce((values, paramKey) => {\n      values.push(allPathName[paramKey.index]);\n      return values;\n    }, []);\n  }\n\n  /**\n   * Returns an array with all named param ids and their position in the path\n   * Private\n   **/\n  function namedParamsWithIndex() {\n    const namedUrlParams = getPathNames(namedUrl);\n\n    return namedUrlParams.reduce((validParams, param, index) => {\n      if (param[0] === ':') {\n        validParams.push({ value: param.slice(1), index });\n      }\n      return validParams;\n    }, []);\n  }\n\n  /**\n   * Wrapper for URL.port\n   *\n   **/\n  function port() {\n    return urlBase.port;\n  }\n\n  /**\n   * Wrapper for URL.pathname\n   *\n   **/\n  function pathname() {\n    return urlBase.pathname;\n  }\n\n  /**\n   * Wrapper for URL.protocol\n   *\n   **/\n  function protocol() {\n    return urlBase.protocol;\n  }\n\n  /**\n   * Wrapper for URL.search\n   *\n   **/\n  function search() {\n    return urlBase.search;\n  }\n\n  /**\n   * Returns an object with all query params and their values\n   *\n   **/\n  function queryParams() {\n    const params = {};\n    urlBase.searchParams.forEach((value, key) => {\n      params[key] = value;\n    });\n\n    return params;\n  }\n\n  /**\n   * Returns an array with all the query param keys\n   *\n   **/\n  function queryParamsKeys() {\n    const params = [];\n    urlBase.searchParams.forEach((_value, key) => {\n      params.push(key);\n    });\n\n    return params;\n  }\n\n  /**\n   * Returns an array with all the query param values\n   *\n   **/\n  function queryParamsValues() {\n    const params = [];\n    urlBase.searchParams.forEach((value) => {\n      params.push(value);\n    });\n\n    return params;\n  }\n\n  /**\n   * Returns an array with all the elements of a pathname\n   *\n   **/\n  function pathNames() {\n    return getPathNames(urlBase.pathname);\n  }\n\n  /**\n   * Returns an array with all the parts of a pathname\n   * Private method\n   **/\n  function getPathNames(pathName) {\n    if (pathName === '/' || pathName.trim().length === 0) return [pathName];\n    if (pathName.slice(-1) === '/') {\n      pathName = pathName.slice(0, -1);\n    }\n    if (pathName[0] === '/') {\n      pathName = pathName.slice(1);\n    }\n\n    return pathName.split('/');\n  }\n\n  return Object.freeze({\n    hash: hash(),\n    host: host(),\n    hostname: hostname(),\n    namedParams: namedParams(),\n    namedParamsKeys: namedParamsKeys(),\n    namedParamsValues: namedParamsValues(),\n    pathNames: pathNames(),\n    port: port(),\n    pathname: pathname(),\n    protocol: protocol(),\n    search: search(),\n    queryParams: queryParams(),\n    queryParamsKeys: queryParamsKeys(),\n    queryParamsValues: queryParamsValues(),\n  });\n};\n\nexport { UrlParser };\n", "/**\n * Returns true if object has any nested routes empty\n * @param routeObject\n **/\nconst anyEmptyNestedRoutes = (routeObject) => {\n  let result = false;\n  if (Object.keys(routeObject).length === 0) {\n    return true;\n  }\n\n  if (routeObject.childRoute && Object.keys(routeObject.childRoute).length === 0) {\n    result = true;\n  } else if (routeObject.childRoute) {\n    result = anyEmptyNestedRoutes(routeObject.childRoute);\n  }\n\n  return result;\n};\n\n/**\n * Compare two routes ignoring named params\n * @param pathName string\n * @param routeName string\n **/\n\nconst compareRoutes = (pathName, routeName) => {\n  routeName = removeSlash(routeName);\n\n  if (routeName.includes(':')) {\n    return routeName.includes(pathName);\n  } else {\n    return routeName.startsWith(pathName);\n  }\n};\n\n/**\n * Returns a boolean indicating if the name of path exists in the route based on the language parameter\n * @param pathName string\n * @param route object\n * @param language string\n **/\n\nconst findLocalisedRoute = (pathName, route, language) => {\n  let exists = false;\n\n  if (language) {\n    return { exists: route.lang && route.lang[language] && route.lang[language].includes(pathName), language };\n  }\n\n  exists = compareRoutes(pathName, route.name);\n\n  if (!exists && route.lang && typeof route.lang === 'object') {\n    for (const [key, value] of Object.entries(route.lang)) {\n      if (compareRoutes(pathName, value)) {\n        exists = true;\n        language = key;\n      }\n    }\n  }\n\n  return { exists, language };\n};\n\n/**\n * Return all the consecutive named param (placeholders) of a pathname\n * @param pathname\n **/\nconst getNamedParams = (pathName = '') => {\n  if (pathName.trim().length === 0) return [];\n  const namedUrlParams = getPathNames(pathName);\n  return namedUrlParams.reduce((validParams, param) => {\n    if (param[0] === ':') {\n      validParams.push(param.slice(1));\n    }\n\n    return validParams;\n  }, []);\n};\n\n/**\n * Split a pathname based on /\n * @param pathName\n * Private method\n **/\nconst getPathNames = (pathName) => {\n  if (pathName === '/' || pathName.trim().length === 0) return [pathName];\n\n  pathName = removeSlash(pathName, 'both');\n\n  return pathName.split('/');\n};\n\n/**\n * Return the first part of a pathname until the first named param is found\n * @param name\n **/\nconst nameToPath = (name = '') => {\n  let routeName;\n  if (name === '/' || name.trim().length === 0) return name;\n  name = removeSlash(name, 'lead');\n  routeName = name.split(':')[0];\n  routeName = removeSlash(routeName, 'trail');\n\n  return routeName.toLowerCase();\n};\n\n/**\n * Return the path name excluding query params\n * @param name\n **/\nconst pathWithoutQueryParams = (currentRoute) => {\n  const path = currentRoute.path.split('?');\n  return path[0];\n};\n\n/**\n * Return the path name including query params\n * @param name\n **/\nconst pathWithQueryParams = (currentRoute) => {\n  let queryParams = [];\n  if (currentRoute.queryParams) {\n    for (let [key, value] of Object.entries(currentRoute.queryParams)) {\n      queryParams.push(`${key}=${value}`);\n    }\n  }\n\n  const hash = currentRoute.hash ? currentRoute.hash : '';\n\n  if (queryParams.length > 0) {\n    return `${currentRoute.path}?${queryParams.join('&')}${hash}`;\n  } else {\n    return currentRoute.path + hash;\n  }\n};\n\n/**\n * Returns a string with trailing or leading slash character removed\n * @param pathName string\n * @param position string - lead, trail, both\n **/\nconst removeExtraPaths = (pathNames, basePathNames) => {\n  const names = basePathNames.split('/');\n  if (names.length > 1) {\n    names.forEach(function (name, index) {\n      if (name.length > 0 && index > 0) {\n        pathNames.shift();\n      }\n    });\n  }\n\n  return pathNames;\n};\n\n/**\n * Returns a string with trailing or leading slash character removed\n * @param pathName string\n * @param position string - lead, trail, both\n **/\n\nconst removeSlash = (pathName, position = 'lead') => {\n  if (position === 'trail' || position === 'both') {\n    pathName = pathName.replace(/\\/$/, '');\n  }\n\n  if (position === 'lead' || position === 'both') {\n    pathName = pathName.replace(/^\\//, '');\n  }\n\n  return pathName;\n};\n\n/**\n * Returns the name of the route based on the language parameter\n * @param route object\n * @param language string\n **/\n\nconst routeNameLocalised = (route, language = null) => {\n  if (!language || !route.lang || !route.lang[language]) {\n    return route.name;\n  } else {\n    return route.lang[language];\n  }\n};\n\n/**\n * Return the path name excluding query params\n * @param name\n **/\nconst startsWithNamedParam = (currentRoute) => {\n  const routeName = removeSlash(currentRoute);\n\n  return routeName.startsWith(':');\n};\n\n/**\n * Updates the base route path.\n * Route objects can have nested routes (childRoutes) or just a long name like \"admin/employees/show/:id\"\n *\n * @param basePath string\n * @param pathNames array\n * @param route object\n * @param language string\n **/\n\nconst updateRoutePath = (basePath, pathNames, route, language, convert = false) => {\n  if (basePath === '/' || basePath.trim().length === 0) return { result: basePath, language: null };\n\n  let basePathResult = basePath;\n  let routeName = route.name;\n  let currentLanguage = language;\n\n  if (convert) {\n    currentLanguage = '';\n  }\n\n  routeName = removeSlash(routeName);\n  basePathResult = removeSlash(basePathResult);\n\n  if (!route.childRoute) {\n    let localisedRoute = findLocalisedRoute(basePathResult, route, currentLanguage);\n\n    if (localisedRoute.exists && convert) {\n      basePathResult = routeNameLocalised(route, language);\n    }\n\n    let routeNames = routeName.split(':')[0];\n    routeNames = removeSlash(routeNames, 'trail');\n    routeNames = routeNames.split('/');\n    routeNames.shift();\n    routeNames.forEach(() => {\n      const currentPathName = pathNames[0];\n      localisedRoute = findLocalisedRoute(`${basePathResult}/${currentPathName}`, route, currentLanguage);\n\n      if (currentPathName && localisedRoute.exists) {\n        if (convert) {\n          basePathResult = routeNameLocalised(route, language);\n        } else {\n          basePathResult = `${basePathResult}/${currentPathName}`;\n        }\n        pathNames.shift();\n      } else {\n        return { result: basePathResult, language: localisedRoute.language };\n      }\n    });\n    return { result: basePathResult, language: localisedRoute.language };\n  } else {\n    return { result: basePath, language: currentLanguage };\n  }\n};\n\nexport {\n  anyEmptyNestedRoutes,\n  compareRoutes,\n  findLocalisedRoute,\n  getNamedParams,\n  getPathNames,\n  nameToPath,\n  pathWithQueryParams,\n  pathWithoutQueryParams,\n  removeExtraPaths,\n  removeSlash,\n  routeNameLocalised,\n  startsWithNamedParam,\n  updateRoutePath,\n};\n", "import { UrlParser } from './url_parser';\n\nimport { pathWithQueryParams, removeSlash } from '../lib/utils';\n\nconst RouterCurrent = (trackPage) => {\n  const trackPageview = trackPage || false;\n  let activeRoute = '';\n\n  const setActive = (newRoute, updateBrowserHistory) => {\n    activeRoute = newRoute.path;\n    pushActiveRoute(newRoute, updateBrowserHistory);\n  };\n\n  const active = () => {\n    return activeRoute;\n  };\n\n  /**\n   * Returns true if pathName is current active route\n   * @param pathName String The path name to check against the current route.\n   * @param includePath Boolean if true checks that pathName is included in current route. If false should match it.\n   **/\n  const isActive = (queryPath, includePath = false) => {\n    if (queryPath[0] !== '/') {\n      queryPath = '/' + queryPath;\n    }\n\n    // remove query params for comparison\n    let pathName = UrlParser(`http://fake.com${queryPath}`).pathname;\n    let activeRoutePath = UrlParser(`http://fake.com${activeRoute}`).pathname;\n\n    pathName = removeSlash(pathName, 'trail');\n\n    activeRoutePath = removeSlash(activeRoutePath, 'trail');\n\n    if (includePath) {\n      return activeRoutePath.includes(pathName);\n    } else {\n      return activeRoutePath === pathName;\n    }\n  };\n\n  const pushActiveRoute = (newRoute, updateBrowserHistory) => {\n    if (typeof window !== 'undefined') {\n      const pathAndSearch = pathWithQueryParams(newRoute);\n\n      if (updateBrowserHistory) {\n        window.history.pushState({ page: pathAndSearch }, '', pathAndSearch);\n      }\n      // Moving back in history does not update browser history but does update tracking.\n      if (trackPageview) {\n        gaTracking(pathAndSearch);\n      }\n    }\n  };\n\n  const gaTracking = (newPage) => {\n    if (typeof ga !== 'undefined') {\n      ga('set', 'page', newPage);\n      ga('send', 'pageview');\n    }\n  };\n\n  return Object.freeze({ active, isActive, setActive });\n};\n\nexport { RouterCurrent };\n", "export const RouterGuard = (onlyIf) => {\n  const guardInfo = onlyIf;\n\n  const valid = () => {\n    return guardInfo && guardInfo.guard && typeof guardInfo.guard === 'function';\n  };\n\n  const redirect = () => {\n    return !guardInfo.guard();\n  };\n\n  const redirectPath = () => {\n    let destinationUrl = '/';\n    if (guardInfo.redirect && guardInfo.redirect.length > 0) {\n      destinationUrl = guardInfo.redirect;\n    }\n\n    return destinationUrl;\n  };\n\n  return Object.freeze({ valid, redirect, redirectPath });\n};\n", "import { RouterGuard } from './guard';\n\nconst RouterRedirect = (route, currentPath) => {\n  const guard = RouterGuard(route.onlyIf);\n\n  const path = () => {\n    let redirectTo = currentPath;\n    if (route.redirectTo && route.redirectTo.length > 0) {\n      redirectTo = route.redirectTo;\n    }\n\n    if (guard.valid() && guard.redirect()) {\n      redirectTo = guard.redirectPath();\n    }\n\n    return redirectTo;\n  };\n\n  return Object.freeze({ path });\n};\n\nexport { RouterRedirect };\n", "import { UrlParser } from './url_parser';\n\nfunction RouterRoute({ routeInfo, path, routeNamedParams, urlParser, namedPath, language }) {\n  const namedParams = () => {\n    const parsedParams = UrlParser(`https://fake.com${urlParser.pathname}`, namedPath).namedParams;\n\n    return { ...routeNamedParams, ...parsedParams };\n  };\n\n  const get = () => {\n    return {\n      name: path,\n      component: routeInfo.component,\n      hash: urlParser.hash,\n      layout: routeInfo.layout,\n      queryParams: urlParser.queryParams,\n      namedParams: namedParams(),\n      path,\n      language,\n    };\n  };\n\n  return Object.freeze({ get, namedParams });\n}\n\nexport { RouterRoute };\n", "import {\n  getNamedParams,\n  nameToPath,\n  updateRoutePath,\n  removeExtraPaths,\n  routeNameLocalised\n} from '../lib/utils';\n\nfunction RouterPath({ basePath, basePathName, pathNames, convert, currentLanguage }) {\n  let updatedPathRoute;\n  let route;\n  let routePathLanguage = currentLanguage;\n\n  function updatedPath(currentRoute) {\n    route = currentRoute;\n    updatedPathRoute = updateRoutePath(basePathName, pathNames, route, routePathLanguage, convert);\n    routePathLanguage = convert ? currentLanguage : updatedPathRoute.language;\n\n    return updatedPathRoute;\n  }\n\n  function localisedPathName() {\n    return routeNameLocalised(route, routePathLanguage);\n  }\n\n  function localisedRouteWithoutNamedParams() {\n    return nameToPath(localisedPathName());\n  }\n\n  function basePathNameWithoutNamedParams() {\n    return nameToPath(updatedPathRoute.result);\n  }\n\n  function namedPath() {\n    let localisedPath = localisedPathName();\n    if (localisedPath && !localisedPath.startsWith('/')) {\n      localisedPath = '/' + localisedPath;\n    }\n\n    return basePath ? `${basePath}${localisedPath}` : localisedPath;\n  }\n\n  function routePath() {\n    let routePathValue = `${basePath}/${basePathNameWithoutNamedParams()}`;\n    if (routePathValue === '//') {\n      routePathValue = '/';\n    }\n\n    if (routePathLanguage) {\n      pathNames = removeExtraPaths(pathNames, localisedRouteWithoutNamedParams());\n    }\n\n    const namedParams = getNamedParams(localisedPathName());\n    if (namedParams && namedParams.length > 0) {\n      namedParams.forEach(function () {\n        if (pathNames.length > 0) {\n          routePathValue += `/${pathNames.shift()}`;\n        }\n      });\n    }\n\n    return routePathValue;\n  }\n\n  function routeLanguage() {\n    return routePathLanguage;\n  }\n\n  function basePathSameAsLocalised() {\n    return basePathNameWithoutNamedParams() === localisedRouteWithoutNamedParams();\n  }\n\n  return Object.freeze({\n    basePathSameAsLocalised,\n    updatedPath,\n    basePathNameWithoutNamedParams,\n    localisedPathName,\n    localisedRouteWithoutNamedParams,\n    namedPath,\n    pathNames,\n    routeLanguage,\n    routePath,\n  });\n}\n\nexport { RouterPath };\n", "import { UrlParser } from './url_parser';\nimport { RouterRedirect } from './redirect';\nimport { RouterRoute } from './route';\nimport { RouterPath } from './path';\nimport { anyEmptyNestedRoutes, pathWithoutQueryParams, startsWithNamedParam } from '../lib/utils';\n\nconst NotFoundPage = '/404.html';\n\nfunction RouterFinder({ routes, currentUrl, routerOptions, convert }) {\n  const defaultLanguage = routerOptions.defaultLanguage;\n  const sitePrefix = routerOptions.prefix ? routerOptions.prefix.toLowerCase() : '';\n  const urlParser = parseCurrentUrl(currentUrl, sitePrefix);\n  let redirectTo = '';\n  let routeNamedParams = {};\n  let staticParamMatch = false;\n\n  function findActiveRoute() {\n    let searchActiveRoute = searchActiveRoutes(routes, '', urlParser.pathNames, routerOptions.lang, convert);\n\n    if (!searchActiveRoute || !Object.keys(searchActiveRoute).length || anyEmptyNestedRoutes(searchActiveRoute)) {\n      if (typeof window !== 'undefined') {\n        searchActiveRoute = routeNotFound(routerOptions.lang);\n      }\n    } else {\n      searchActiveRoute.path = pathWithoutQueryParams(searchActiveRoute);\n      if (sitePrefix) {\n        searchActiveRoute.path = `/${sitePrefix}${searchActiveRoute.path}`;\n      }\n    }\n\n    return searchActiveRoute;\n  }\n\n  /**\n   * Gets an array of routes and the browser pathname and return the active route\n   * @param routes\n   * @param basePath\n   * @param pathNames\n   **/\n  function searchActiveRoutes(routes, basePath, pathNames, currentLanguage, convert) {\n    let currentRoute = {};\n    let basePathName = pathNames.shift().toLowerCase();\n    const routerPath = RouterPath({ basePath, basePathName, pathNames, convert, currentLanguage });\n    staticParamMatch = false;\n\n    routes.forEach(function (route) {\n      routerPath.updatedPath(route);\n\n      if (matchRoute(routerPath, route.name)) {\n        let routePath = routerPath.routePath();\n        redirectTo = RouterRedirect(route, redirectTo).path();\n\n        if (currentRoute.name !== routePath) {\n          currentRoute = setCurrentRoute({\n            route,\n            routePath,\n            routeLanguage: routerPath.routeLanguage(),\n            urlParser,\n            namedPath: routerPath.namedPath(),\n          });\n        }\n\n        if (route.nestedRoutes && route.nestedRoutes.length > 0 && routerPath.pathNames.length > 0) {\n          currentRoute.childRoute = searchActiveRoutes(\n            route.nestedRoutes,\n            routePath,\n            routerPath.pathNames,\n            routerPath.routeLanguage(),\n            convert\n          );\n          currentRoute.path = currentRoute.childRoute.path;\n          currentRoute.language = currentRoute.childRoute.language;\n        } else if (nestedRoutesAndNoPath(route, routerPath.pathNames)) {\n          const indexRoute = searchActiveRoutes(\n            route.nestedRoutes,\n            routePath,\n            ['index'],\n            routerPath.routeLanguage(),\n            convert\n          );\n          if (indexRoute && Object.keys(indexRoute).length > 0) {\n            currentRoute.childRoute = indexRoute;\n            currentRoute.language = currentRoute.childRoute.language;\n          }\n        }\n      }\n    });\n\n    if (redirectTo) {\n      currentRoute.redirectTo = redirectTo;\n    }\n\n    return currentRoute;\n  }\n\n  function matchRoute(routerPath, routeName) {\n    const basePathSameAsLocalised = routerPath.basePathSameAsLocalised();\n    if (basePathSameAsLocalised) {\n      staticParamMatch = true;\n    }\n\n    return basePathSameAsLocalised || (!staticParamMatch && startsWithNamedParam(routeName));\n  }\n\n  function nestedRoutesAndNoPath(route, pathNames) {\n    return route.nestedRoutes && route.nestedRoutes.length > 0 && pathNames.length === 0;\n  }\n\n  function parseCurrentUrl(currentUrl, sitePrefix) {\n    if (sitePrefix && sitePrefix.trim().length > 0) {\n      const replacePattern = currentUrl.endsWith(sitePrefix) ? sitePrefix : sitePrefix + \"/\";\n      const noPrefixUrl = currentUrl.replace(replacePattern, '');\n      return UrlParser(noPrefixUrl);\n    } else {\n      return UrlParser(currentUrl);\n    }\n  }\n\n  function setCurrentRoute({ route, routePath, routeLanguage, urlParser, namedPath }) {\n    const routerRoute = RouterRoute({\n      routeInfo: route,\n      urlParser,\n      path: routePath,\n      routeNamedParams,\n      namedPath,\n      language: routeLanguage || defaultLanguage,\n    });\n    routeNamedParams = routerRoute.namedParams();\n\n    return routerRoute.get();\n  }\n\n  const routeNotFound = (customLanguage) => {\n    const custom404Page = routes.find((route) => route.name == '404');\n    const language = customLanguage || defaultLanguage || '';\n    if (custom404Page) {\n      return { ...custom404Page, language, path: '404' };\n    } else {\n      return { name: '404', component: '', path: '404', redirectTo: NotFoundPage };\n    }\n  };\n\n  return Object.freeze({ findActiveRoute });\n}\n\nexport { RouterFinder };\n", "import { activeRoute } from './store';\nimport { RouterCurrent } from './router/current';\nimport { RouterFinder } from './router/finder';\nimport { removeSlash } from './lib/utils';\n\nconst NotFoundPage = '/404.html';\n\nlet userDefinedRoutes = [];\nlet routerOptions = {};\nlet routerCurrent;\n\n/**\n * Object exposes one single property: activeRoute\n * @param routes  Array of routes\n * @param currentUrl current url\n * @param options configuration options\n **/\nconst SpaRouter = (routes, currentUrl, options = {}) => {\n  routerOptions = { ...options };\n  if (typeof currentUrl === 'undefined' || currentUrl === '') {\n    currentUrl = document.location.href;\n  }\n\n  routerCurrent = RouterCurrent(routerOptions.gaPageviews);\n\n  currentUrl = removeSlash(currentUrl, 'trail');\n  userDefinedRoutes = routes;\n\n  const findActiveRoute = () => {\n    let convert = false;\n\n    if (routerOptions.langConvertTo) {\n      routerOptions.lang = routerOptions.langConvertTo;\n      convert = true;\n    }\n\n    return RouterFinder({ routes, currentUrl, routerOptions, convert }).findActiveRoute();\n  };\n\n  /**\n   * Redirect current route to another\n   * @param destinationUrl\n   **/\n  const navigateNow = (destinationUrl, updateBrowserHistory) => {\n    if (typeof window !== 'undefined') {\n      if (destinationUrl === NotFoundPage) {\n        routerCurrent.setActive({ path: NotFoundPage }, updateBrowserHistory);\n      } else {\n        navigateTo(destinationUrl);\n      }\n    }\n\n    return destinationUrl;\n  };\n\n  const setActiveRoute = (updateBrowserHistory = true) => {\n    const currentRoute = findActiveRoute();\n    if (currentRoute.redirectTo) {\n      return navigateNow(currentRoute.redirectTo, updateBrowserHistory);\n    }\n\n    routerCurrent.setActive(currentRoute, updateBrowserHistory);\n    activeRoute.set(currentRoute);\n\n    return currentRoute;\n  };\n\n  return Object.freeze({\n    setActiveRoute,\n    findActiveRoute,\n  });\n};\n\n/**\n * Converts a route to its localised version\n * @param pathName\n **/\nconst localisedRoute = (pathName, language) => {\n  pathName = removeSlash(pathName, 'lead');\n  routerOptions.langConvertTo = language;\n\n  return SpaRouter(userDefinedRoutes, 'http://fake.com/' + pathName, routerOptions).findActiveRoute();\n};\n\n/**\n * Updates the current active route and updates the browser pathname\n * @param pathName String\n * @param language String\n * @param updateBrowserHistory Boolean\n **/\nconst navigateTo = (pathName, language = null, updateBrowserHistory = true) => {\n  pathName = removeSlash(pathName, 'lead');\n\n  if (language) {\n    routerOptions.langConvertTo = language;\n  }\n\n  return SpaRouter(userDefinedRoutes, 'http://fake.com/' + pathName, routerOptions).setActiveRoute(\n    updateBrowserHistory\n  );\n};\n\n/**\n * Returns true if pathName is current active route\n * @param pathName String The path name to check against the current route.\n * @param includePath Boolean if true checks that pathName is included in current route. If false should match it.\n **/\nconst routeIsActive = (queryPath, includePath = false) => {\n  return routerCurrent.isActive(queryPath, includePath);\n};\n\nif (typeof window !== 'undefined') {\n  // Avoid full page reload on local routes\n  window.addEventListener('click', (event) => {\n    if (event.target.localName.toLowerCase() !== 'a') return;\n    if (event.metaKey || event.ctrlKey || event.shiftKey) return;\n\n    const sitePrefix = routerOptions.prefix ? `/${routerOptions.prefix.toLowerCase()}` : '';\n    const targetHostNameInternal = event.target.pathname && event.target.host === window.location.host;\n    const prefixMatchPath = sitePrefix.length > 1 ? event.target.pathname.startsWith(sitePrefix) : true;\n\n    if (targetHostNameInternal && prefixMatchPath) {\n      event.preventDefault();\n      let navigatePathname = event.target.pathname + event.target.search;\n\n      const destinationUrl = navigatePathname + event.target.search + event.target.hash;\n      if (event.target.target === '_blank') {\n        window.open(destinationUrl, 'newTab');\n      } else {\n        navigateTo(destinationUrl);\n      }\n    }\n  });\n\n  window.onpopstate = function (_event) {\n    let navigatePathname = window.location.pathname + window.location.search + window.location.hash;\n\n    navigateTo(navigatePathname, null, false);\n  };\n}\n\nexport { SpaRouter, localisedRoute, navigateTo, routeIsActive };\n", null, null, null],
  "mappings": "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",
  "names": ["getPathNames", "localisedRoute", "activeRoute", "routerOptions", "routes", "convert", "currentUrl", "sitePrefix", "urlParser", "NotFoundPage", "ctx", "ctx", "ctx"]
}

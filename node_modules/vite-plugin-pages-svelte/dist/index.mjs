// src/utils/validate.ts
import { resolve, extname } from "path";

// src/utils/convert.ts
import { basename } from "path";
function pathToName(filepath) {
  return filepath.replace(/[_.\-\\/]/g, "_").replace(/[[:\]()]/g, "$");
}
function slash(str) {
  return str.replace(/\\/g, "/");
}

// src/utils/validate.ts
function isPagesDir(path, options) {
  for (const page of options.pagesDir) {
    const dirPath = slash(resolve(options.root, page));
    if (path.startsWith(dirPath))
      return true;
  }
  return false;
}
function isTarget(path, options) {
  return isPagesDir(path, options) && options.extensionsRE.test(path);
}
function isDynamicRoute(routePath) {
  return /^\[.+\]$/.test(routePath);
}
function isCatchAllRoute(routePath) {
  return /^\[\.{3}all\]$/.test(routePath);
}
function containsExtension(path, extensions) {
  const ext = extname(path).slice(1);
  return extensions.includes(ext);
}

// src/crawler/crawler.ts
import { opendir } from "fs/promises";
import { resolve as resolve2, extname as extname2 } from "path";
async function traverse(path, extensions, ignore) {
  const r = [];
  const dir = await opendir(path, { bufferSize: 64 });
  for await (const dirent of dir) {
    if (dirent.isFile()) {
      if (ignore.includes(dirent.name))
        continue;
      if (extensions.length > 0 && !containsExtension(dirent.name, extensions))
        continue;
      r.push({ path: resolve2(path, dirent.name) });
    } else if (dirent.isDirectory()) {
      if (ignore.includes(dirent.name))
        continue;
      r.push({
        path: resolve2(path, dirent.name),
        children: await traverse(resolve2(path, dirent.name), extensions, ignore)
      });
    }
  }
  return r;
}
function haveChildren(files) {
  if (files.children && Array.isArray(files.children) && files.children.length > 0)
    return true;
  return false;
}

// src/utils/route.ts
function sortRoute(a) {
  if (a.name === "/")
    return -1;
  if (/^\/[A-Za-z0-9]/.test(a.name))
    return -1;
  if (/^\/:/.test(a.name))
    return 1;
  return 1;
}

// src/stringify.ts
function stringifyRoutes(preparedRoutes) {
  const imports = [];
  let stringRoutes = "[";
  for (const route of preparedRoutes) {
    const { out, imp } = compileRouteItem(route);
    stringRoutes += out;
    imports.push(...imp);
  }
  stringRoutes += "]";
  return {
    imports,
    stringRoutes
  };
}
function compileRouteItem(route) {
  var _a;
  let out = "{ ";
  const imp = [];
  if (haveChildren(route)) {
    const children = (_a = route.children) == null ? void 0 : _a.sort(sortRoute).map((o) => compileRouteItem(o));
    const nestedRoutes = [...children.map((o) => o.out.replace('name: "/",', 'name: "index",'))];
    out += `name: "${route.name}", nestedRoutes: [${nestedRoutes.join(",")}]
`;
    const imps = children == null ? void 0 : children.map((o) => o.imp).flat();
    imp.push(...imps);
  } else {
    const importName = pathToName(route.path);
    const importStr = `import ${importName} from "${route.path}"`;
    if (!imp.includes(importStr)) {
      imp.push(importStr);
    }
    out += `name: "${route.name}", component: ${importName}
`;
  }
  out += "},\n";
  return {
    out,
    imp
  };
}

// src/generate.ts
import { extname as extname3 } from "path";
function generateRoutes(pages) {
  const routes = [];
  for (let i = 0; i < pages.length; i++) {
    const node = pages[i].path.split("/")[pages[i].path.split("/").length - 1];
    const fileExt = extname3(node);
    const isDynamic = isDynamicRoute(node.replace(fileExt, ""));
    const isCatchAll = isCatchAllRoute(node.replace(fileExt, ""));
    const normalizedName = isDynamic ? node.replace(fileExt, "").replace(/^\[(\.{3})?/, "").replace(/\]$/, "") : node.replace(fileExt, "");
    const normalizedPath = normalizedName.toLowerCase();
    let name;
    if (normalizedPath === "index") {
      name = "/";
    } else {
      if (isCatchAll) {
        name = "/*";
      } else if (isDynamic) {
        name = `/:${normalizedName}`;
      } else {
        name = `/${normalizedPath}`;
      }
    }
    if (!haveChildren(pages[i])) {
      routes.push({
        name,
        path: pages[i].path
      });
      continue;
    }
    routes.push({
      name,
      children: generateRoutes(pages[i].children)
    });
  }
  return routes;
}
function generateClientCode(routes) {
  const { imports, stringRoutes } = stringifyRoutes(routes.sort(sortRoute));
  return `${imports.join(";\n")}${imports.length > 1 ? ";" : ""}

const routes = ${stringRoutes};

export default routes;`;
}

// src/utils/vite.ts
import Debug from "debug";

// src/constants.ts
var MODULE_IDS = ["pages-generated-svelte", "virtual:generated-pages-svelte"];
var MODULE_ID_VIRTUAL = "/@vite-plugin-pages/generated-pages-svelte";

// src/utils/vite.ts
var debug = {
  hmr: Debug("vite-plugin-pages-svelte:hmr"),
  parser: Debug("vite-plugin-pages-svelte:parser"),
  gen: Debug("vite-plugin-pages-svelte:gen"),
  options: Debug("vite-plugin-pages-svelte:options"),
  cache: Debug("vite-plugin-pages-svelte:cache"),
  pages: Debug("vite-plugin-pages-svelte:pages")
};
function getPagesVirtualModule(server) {
  const { moduleGraph } = server;
  const module = moduleGraph.getModuleById(MODULE_ID_VIRTUAL);
  if (module) {
    moduleGraph.invalidateModule(module);
    return module;
  }
  return null;
}

// src/options.ts
async function resolveOptions(userOptions, viteRoot) {
  const { pagesDir = "src/pages", exclude = [], syncIndex = true } = userOptions;
  const root = viteRoot || slash(process.cwd());
  const extensions = userOptions.extensions || ["svelte"];
  const extensionsRE = new RegExp(`\\.(${extensions.join("|")})$`);
  const resolvedOptions = {
    pagesDir,
    root,
    extensions,
    exclude,
    syncIndex,
    extensionsRE
  };
  return resolvedOptions;
}

// src/pages.ts
import { resolve as resolve4 } from "path";

// src/files.ts
import { resolve as resolve3 } from "path";
async function getPageFiles(path, options) {
  const { exclude, extensions } = options;
  const files = await traverse(path, extensions, exclude);
  return files;
}

// src/pages.ts
async function resolvePages(options) {
  const pages = [];
  const pageDirFiles = {
    pageDir: options.pagesDir,
    files: await getPageFiles(slash(resolve4(options.root, options.pagesDir)), options)
  };
  for (const file of pageDirFiles.files) {
    pages.push(file);
  }
  const routes = [];
  for (const page of pages.values()) {
    if (!routes.includes(page.path))
      routes.push(page.path);
    else
      throw new Error(`[vite-plugin-pages] duplicate route in ${page.path}`);
  }
  return pages;
}

// src/hmr.ts
function handleHMR(server, pages, options, clearRoutes) {
  const { ws, watcher } = server;
  function fullReload() {
    getPagesVirtualModule(server);
    clearRoutes();
    ws.send({
      type: "full-reload"
    });
  }
  watcher.on("add", async (file) => {
    const path = slash(file);
    if (isTarget(path, options)) {
      const p = await resolvePages(options);
      pages.length = 0;
      pages.push(...p);
      debug.hmr("add", p);
      fullReload();
    }
  });
  watcher.on("unlink", async (file) => {
    const path = slash(file);
    if (isTarget(path, options)) {
      const p = await resolvePages(options);
      pages.length = 0;
      pages.push(...p);
      debug.hmr("remove", p);
      fullReload();
    }
  });
}

// src/index.ts
function pagesPlugin(userOptions = {}) {
  let generatedRoutes = null;
  let options;
  let pages;
  return {
    name: "vite-plugin-pages-svelte",
    enforce: "pre",
    async configResolved({ root }) {
      options = await resolveOptions(userOptions, root);
      pages = await resolvePages(options);
      debug.options(options);
      debug.pages(pages);
    },
    configureServer(server) {
      handleHMR(server, pages, options, () => {
        generatedRoutes = null;
      });
    },
    resolveId(id) {
      return MODULE_IDS.includes(id) || MODULE_IDS.some((i) => id.startsWith(i)) ? MODULE_ID_VIRTUAL : null;
    },
    load(id) {
      if (id !== MODULE_ID_VIRTUAL)
        return;
      if (!generatedRoutes) {
        generatedRoutes = generateRoutes(pages);
      }
      const clientCode = generateClientCode(generatedRoutes);
      debug.gen("client code: %O", clientCode);
      return clientCode;
    },
    transform(_code, id) {
      if (!/svelte&type=route/.test(id))
        return;
      return {
        code: "export default {};",
        map: null
      };
    },
    generateBundle(_options, bundle) {
      bundle;
    }
  };
}
var src_default = pagesPlugin;
export {
  src_default as default,
  generateRoutes
};
